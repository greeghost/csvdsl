/*
 * generated by Xtext 2.28.0
 */
package org.xtext.first.csvdsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.first.csvdsl.csvDsl.Assign;
import org.xtext.first.csvdsl.csvDsl.ColRange;
import org.xtext.first.csvdsl.csvDsl.CsvDslPackage;
import org.xtext.first.csvdsl.csvDsl.Csv_variable;
import org.xtext.first.csvdsl.csvDsl.Direct;
import org.xtext.first.csvdsl.csvDsl.Drop;
import org.xtext.first.csvdsl.csvDsl.Int_variable;
import org.xtext.first.csvdsl.csvDsl.Load;
import org.xtext.first.csvdsl.csvDsl.Model;
import org.xtext.first.csvdsl.csvDsl.Print;
import org.xtext.first.csvdsl.csvDsl.Product;
import org.xtext.first.csvdsl.csvDsl.RowRange;
import org.xtext.first.csvdsl.csvDsl.Save;
import org.xtext.first.csvdsl.csvDsl.Select;
import org.xtext.first.csvdsl.csvDsl.Sum;
import org.xtext.first.csvdsl.services.CsvDslGrammarAccess;

@SuppressWarnings("all")
public class CsvDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CsvDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CsvDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CsvDslPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case CsvDslPackage.COL_RANGE:
				sequence_ColRange(context, (ColRange) semanticObject); 
				return; 
			case CsvDslPackage.CSV_VARIABLE:
				sequence_Csv_variable(context, (Csv_variable) semanticObject); 
				return; 
			case CsvDslPackage.DIRECT:
				sequence_Direct(context, (Direct) semanticObject); 
				return; 
			case CsvDslPackage.DROP:
				sequence_Drop(context, (Drop) semanticObject); 
				return; 
			case CsvDslPackage.INT_VARIABLE:
				sequence_Int_variable(context, (Int_variable) semanticObject); 
				return; 
			case CsvDslPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case CsvDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CsvDslPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case CsvDslPackage.PRODUCT:
				sequence_Product(context, (Product) semanticObject); 
				return; 
			case CsvDslPackage.ROW_RANGE:
				sequence_RowRange(context, (RowRange) semanticObject); 
				return; 
			case CsvDslPackage.SAVE:
				sequence_Save(context, (Save) semanticObject); 
				return; 
			case CsvDslPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case CsvDslPackage.SUM:
				sequence_Sum(context, (Sum) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Assign
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     ((val=Csv_variable op=CsvOperation) | (var=Int_variable op=IntOperation))
	 * </pre>
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Range returns ColRange
	 *     ColRange returns ColRange
	 *
	 * Constraint:
	 *     (column=INT | (columnStart=INT columnEnd=INT))
	 * </pre>
	 */
	protected void sequence_ColRange(ISerializationContext context, ColRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Csv_variable returns Csv_variable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Csv_variable(ISerializationContext context, Csv_variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.CSV_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.CSV_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCsv_variableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntOperation returns Direct
	 *     Direct returns Direct
	 *
	 * Constraint:
	 *     val=INT
	 * </pre>
	 */
	protected void sequence_Direct(ISerializationContext context, Direct semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.DIRECT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.DIRECT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectAccess().getValINTTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CsvOperation returns Drop
	 *     Drop returns Drop
	 *
	 * Constraint:
	 *     (newCsv=Csv_variable csv_var=Csv_variable range=Range)
	 * </pre>
	 */
	protected void sequence_Drop(ISerializationContext context, Drop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.DROP__NEW_CSV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.DROP__NEW_CSV));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.DROP__CSV_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.DROP__CSV_VAR));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.DROP__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.DROP__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropAccess().getNewCsvCsv_variableParserRuleCall_0_0(), semanticObject.getNewCsv());
		feeder.accept(grammarAccess.getDropAccess().getCsv_varCsv_variableParserRuleCall_2_0(), semanticObject.getCsv_var());
		feeder.accept(grammarAccess.getDropAccess().getRangeRangeParserRuleCall_5_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Int_variable returns Int_variable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Int_variable(ISerializationContext context, Int_variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.INT_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.INT_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInt_variableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CsvOperation returns Load
	 *     Load returns Load
	 *
	 * Constraint:
	 *     filename=STRING
	 * </pre>
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.LOAD__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.LOAD__FILENAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadAccess().getFilenameSTRINGTerminalRuleCall_2_0(), semanticObject.getFilename());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     statement+=Statement+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     (val=IntOperation | val=Int_variable)
	 * </pre>
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntOperation returns Product
	 *     Product returns Product
	 *
	 * Constraint:
	 *     (var=Int_variable selection=Csv_variable)
	 * </pre>
	 */
	protected void sequence_Product(ISerializationContext context, Product semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.PRODUCT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.PRODUCT__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.PRODUCT__SELECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.PRODUCT__SELECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProductAccess().getVarInt_variableParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getProductAccess().getSelectionCsv_variableParserRuleCall_4_0(), semanticObject.getSelection());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Range returns RowRange
	 *     RowRange returns RowRange
	 *
	 * Constraint:
	 *     (row=INT | (rowStart=INT rowEnd=INT))
	 * </pre>
	 */
	protected void sequence_RowRange(ISerializationContext context, RowRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Save
	 *     Save returns Save
	 *
	 * Constraint:
	 *     (declared_csv=Csv_variable filename=STRING)
	 * </pre>
	 */
	protected void sequence_Save(ISerializationContext context, Save semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SAVE__DECLARED_CSV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SAVE__DECLARED_CSV));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SAVE__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SAVE__FILENAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSaveAccess().getDeclared_csvCsv_variableParserRuleCall_2_0(), semanticObject.getDeclared_csv());
		feeder.accept(grammarAccess.getSaveAccess().getFilenameSTRINGTerminalRuleCall_4_0(), semanticObject.getFilename());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CsvOperation returns Select
	 *     Select returns Select
	 *
	 * Constraint:
	 *     (newCsv=Csv_variable csv_var=Csv_variable range=Range)
	 * </pre>
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SELECT__NEW_CSV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SELECT__NEW_CSV));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SELECT__CSV_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SELECT__CSV_VAR));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SELECT__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SELECT__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectAccess().getNewCsvCsv_variableParserRuleCall_0_0(), semanticObject.getNewCsv());
		feeder.accept(grammarAccess.getSelectAccess().getCsv_varCsv_variableParserRuleCall_2_0(), semanticObject.getCsv_var());
		feeder.accept(grammarAccess.getSelectAccess().getRangeRangeParserRuleCall_5_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntOperation returns Sum
	 *     Sum returns Sum
	 *
	 * Constraint:
	 *     (var=Int_variable selection=Csv_variable)
	 * </pre>
	 */
	protected void sequence_Sum(ISerializationContext context, Sum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SUM__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SUM__VAR));
			if (transientValues.isValueTransient(semanticObject, CsvDslPackage.Literals.SUM__SELECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsvDslPackage.Literals.SUM__SELECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getVarInt_variableParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getSumAccess().getSelectionCsv_variableParserRuleCall_4_0(), semanticObject.getSelection());
		feeder.finish();
	}
	
	
}
